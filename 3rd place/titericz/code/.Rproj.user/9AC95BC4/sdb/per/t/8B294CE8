{
    "contents" : "require(xgboost)\nrequire(data.table)\noptions(stringsAsFactors = FALSE)\npath.wd <- getwd()\n\nall.noexport <- character(0)\n\n\n#############################################################\n# tic toc\n#############################################################\ntic <- function(gcFirst = TRUE, type=c(\"elapsed\", \"user.self\", \"sys.self\")) {\n  type <- match.arg(type)\n  assign(\".type\", type, envir=baseenv())\n  if(gcFirst) gc(FALSE)\n  tic <- proc.time()[type]         \n  assign(\".tic\", tic, envir=baseenv())\n  invisible(tic)\n}\n\ntoc <- function() {\n  type <- get(\".type\", envir=baseenv())\n  toc <- proc.time()[type]\n  tic <- get(\".tic\", envir=baseenv())\n  print(toc - tic)\n  invisible(toc)\n}\n\n\n#############################################################\n# log file path\n#############################################################\nfn.log.file <- function(name) {\n  paste(path.wd, \"log\", name, sep=\"/\")\n}\n\n\n#############################################################\n# data file path\n#############################################################\nfn.data.file <- function(name) {\n  paste(path.wd, \"data\", name, sep=\"/\")\n}\n#############################################################\n# save data file\n#############################################################\nfn.save.data <- function(dt.name, envir = parent.frame()) {\n  save(list = dt.name, \n       file = fn.data.file(paste0(dt.name, \".RData\")), envir = envir)\n}\n#############################################################\n# load saved file\n#############################################################\nfn.load.data <- function(dt.name, envir = parent.frame()) {\n  load(fn.data.file(paste0(dt.name, \".RData\")), envir = envir)\n}\n\nrmse <- function(a,b){\n  r<- sqrt(mean((a-b)^2))\n  r\n}\nsna <- function(x){\n  r<-sum(is.na(x))\n  r\n}\nMode <- function(x) {\n  ux <- unique(x)\n  ux[which.max(tabulate(match(x, ux)))]\n}\n\ncolRank <- function(X) apply(X, 2, rank)\ncolMedian <- function(X) apply(X, 2, median)\ncolMax <- function(X) apply(X, 2, max)\ncolMin <- function(X) apply(X, 2, min)\ncolSd <- function(X) apply(X, 2, sd)\nmae <- function(c1,c2) {\n  c1 <- as.numeric(c1)\n  c2 <- as.numeric(c2)\n  score <- mean( abs(c1-c2) )\n  score\n}\nrep.row<-function(x,n){\n  matrix(rep(x,each=n),nrow=n)\n}\nrep.col<-function(x,n){\n  matrix(rep(x,each=n), ncol=n, byrow=TRUE)\n}\ngc()\nrowMax <- function(X) apply(X, 1, max)\nrowMin <- function(X) apply(X, 1, min)\nrowMean <- function(X) apply(X, 1, mean,na.rm=TRUE)\nrowSd <- function(X) apply(X, 1, sd)\nrowMode <- function(X) apply(X, 1, Mode)\n\n\n\ngetROC_AUC = function(probs, true_Y){\n  probsSort = sort(probs, decreasing = TRUE, index.return = TRUE)\n  val = unlist(probsSort$x)\n  idx = unlist(probsSort$ix)  \n  \n  roc_y = true_Y[idx];\n  stack_x = cumsum(roc_y == 0)/sum(roc_y == 0)\n  stack_y = cumsum(roc_y == 1)/sum(roc_y == 1)    \n  \n  auc = sum((stack_x[2:length(roc_y)]-stack_x[1:length(roc_y)-1])*stack_y[2:length(roc_y)])\n  return(list(stack_x=stack_x, stack_y=stack_y, auc=auc))\n}\n\n\nxgbCV <- function( tr , ts , tgt, MTGT, cv , ite=100 ,shri=0.1, depth=3,subsample=0.5,colsample=1.0, verbose=FALSE ){\n  tr <- as.matrix(tr)\n  ts <- as.matrix(ts)\n  nfolds = max(cv)\n  pred.train <- matrix( 0 ,nrow=nrow(tr), ncol=ncol(MTGT) )\n  pred.test  <- matrix( 0 ,nrow=nrow(ts), ncol=ncol(MTGT) )\n  \n  xgmatTSS <- xgb.DMatrix( ts, missing = -999.0)\n  fold=1\n  for( fold in 1:nfolds  ){\n    px <- which( cv!=fold   )\n    py <- which( cv==fold   )\n    xgmat   <- xgb.DMatrix( tr[px,], label = tgt[px], missing = -999.0)\n    xgmatTS <- xgb.DMatrix( tr[py,], label = tgt[py], missing = -999.0)\n    param <- list(\"objective\" = \"multi:softprob\",\n                  \"num_class\" = ncol(MTGT) ,\n                  \"bst:eta\" = shri,\n                  \"bst:max_depth\" = depth ,\n                  \"subsample\" = subsample,\n                  \"colsample_bytree\" = colsample ,\n                  \"silent\" = 1,\n                  \"nthread\" = 8)\n    watchlist <- list(\"test\"=xgmatTS)\n    bst = xgb.train(param, xgmat, ite )#, watchlist)\n    y <- predict(bst, xgmatTS, ntreelimit=ite)\n    y <- matrix( y , nrow=length(py) , ncol=ncol(MTGT)  , byrow=TRUE )\n    pred.train[py, ] <- y\n    gc()\n    if( verbose==TRUE ){\n      print(paste( fold , llmc(MTGT[py,],pred.train[py,]) , llmc(MTGT[which(cv<=fold),],pred.train[which(cv<=fold),]) ) )\n    }\n    y <- predict(bst, xgmatTSS, ntreelimit=ite)\n    y <- matrix( y , nrow=nrow(ts) , ncol=ncol(MTGT)  , byrow=TRUE )\n    pred.test <- pred.test + y/nfolds\n  }\n\n  list( train=pred.train , test=pred.test )\n}\n\n\nnllmc <- function( apriori , predicted ){\n  s <- rowSums(predicted)\n  s <- matrix( rep(s,ncol(apriori)) , nrow=length(s) , ncol=ncol(apriori) , byrow=FALSE  )\n  predicted <- predicted / s\n  predicted[predicted< 1e-15] <- 1e-15\n  predicted[predicted> (1-1e-15)] <- (1-1e-15)\n  s <- rowSums(predicted)\n  -sum( apriori * log( predicted )  )/nrow(predicted)\n}\nllmc <- function( apriori , predicted ){\n  predicted[predicted< 1e-15] <- 1e-15\n  predicted[predicted> (1-1e-15)] <- (1-1e-15)\n  s <- rowSums(predicted)\n  -sum( apriori * log( predicted )  )/nrow(predicted)\n}\n\n\nrmws  <- function (x) gsub(\"^\\\\s+|\\\\s+$\", \"\", x)\nrmfs  <- function (x) gsub(\"s$\", \"\", x)\nrmfr  <- function (x) gsub(\"r$\", \"\", x)\nrmfing<- function (x) gsub(\"ing$\", \"\", x)\nrmfed <- function (x) gsub(\"ed$\", \"\", x)\nrmfy  <- function (x) gsub(\"y$\", \"\", x)\nrmfn  <- function (x) gsub(\"l$\", \"\", x)\nrmfl  <- function (x) gsub(\"n$\", \"\", x)\n\n\n\n",
    "created" : 1422538642553.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1839114645",
    "id" : "8B294CE8",
    "lastKnownWriteTime" : 1422550832,
    "path" : "F:/Kaggle/boxplots/Doc/code/fn.base.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}